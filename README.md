# üõ∞Ô∏è UART-Vault: FPGA Secure Communication Module with Hardware Encryption 

This project implements a secure UART (Universal Asynchronous Receiver-Transmitter) communication system in Verilog. It addresses the need for privacy in serial data transmission by integrating a lightweight XOR encryption layer directly into the hardware.

The design features a complete UART loopback, where data is encrypted before being sent by the UART transmitter and then decrypted upon reception by the UART receiver. This entire process is handled by synthesizable Verilog, making it suitable for FPGA implementations.

## ‚ú® How It Works:

The security model is elegant in its simplicity, using a dynamic XOR cipher.

1.  **A Secret Key is Forged:** A C program (`keygen.c`) acts as our keymaker, generating a unique, random key and writing it to a Verilog header. Every time you run it, a new secret is created.

2.  **Data is Encrypted:** Before the UART transmitter sends the data down the wire, our `xor_cipher` module instantly encrypts it using the secret key.

3.  **Secure Transmission:** The encrypted data travels across the wire. To an outside observer, it looks like noise.

4.  **Data is Decrypted:** The UART receiver picks up the scrambled data, and the same `xor_cipher` module, armed with the same secret key, instantly decrypts it, restoring the original message.

## üöÄ Features

*   **Standard UART Protocol:** A synthesizable 8-N-1 UART transmitter and receiver.
*   **Lightweight Encryption:** A low-resource XOR cipher provides a fast and effective privacy layer.
*   **Dynamic Key Generation:** Easily generate a new secret key for each build or session.
*   **Ready for Simulation:** Includes a self-verifying testbench to demonstrate the encrypted loopback functionality.

## ‚öôÔ∏è Vivado Simulation Details

To ensure proper simulation, it's crucial to understand how Vivado organizes design and simulation files:

*   **Design Sources vs. Simulation Sources:**
    *   **Design Sources:** Contains all synthesizable Verilog modules that make up your actual hardware design (e.g., `uart_top.v`, `uart_rx.v`, `uart_tx.v`, `xor_cipher.v`). These are used for synthesis and implementation.
    *   **Simulation Sources (`sim_1`):** Must contain *all* Verilog files necessary for simulation, including your testbench (`tb_uart_loopback.v`) AND all the design modules it instantiates. The design files (`uart_top.v`, etc.) will typically appear in both filesets.

*   **Simulation Top Module:** The `tb_uart_loopback.v` file must be designated as the top-level module for your simulation. This tells Vivado where to start the simulation hierarchy.

*   **`key_config.vh`:** This header file, generated by `keygen.c`, is automatically included by `uart_top.v` during compilation. Ensure it exists before running simulation.

## üìà Circuit Implementation

To better understand the hardware, this schematic of the `uart_top` module illustrates the data flow and the integration of our security features.

![UART Top-Level Schematic](uart_schematic.png)

**Legend:**

*   **`uart_top`**: The main module, encapsulating the entire secure UART system.
*   **`tx_din`**: Input port for the plain (unencrypted) data to be transmitted.
*   **`ENC_inst` (Encryption)**: An instance of `xor_cipher` that encrypts `tx_din` using the `KEY`.
*   **`UUT_TX` (UART Transmitter)**: Sends the encrypted data serially.
*   **`internal_serial_link`**: The internal wire connecting the transmitter's output to the receiver's input, simulating the "wire" for loopback.
*   **`UUT_RX` (UART Receiver)**: Receives the encrypted serial data.
*   **`raw_received_data`**: The encrypted data received by `UUT_RX`.
*   **`DEC_inst` (Decryption)**: An instance of `xor_cipher` that decrypts `raw_received_data` using the same `KEY`.
*   **`rx_data`**: Output port for the decrypted, original data.
*   **`KEY`**: The 8-bit encryption/decryption key, sourced from `key_config.vh`.

## üõ†Ô∏è Demonstrating the Secure Loopback

See the security in action by running the included simulation.

### Step 1: Forge the Key

First, you must create the secret key. You'll need `gcc` or another C compiler.

```sh
# Compile the keymaker
gcc keygen.c -o keygen

# Run it to generate the secret key file (src/key_config.vh)
./keygen
```

### Step 2: Launch the Simulation in Vivado

1.  **Set up the Project:** Add all `.v` files from the `src/` and `sim/` directories to your Vivado simulation sources (`sim_1`).
2.  **Assign the Leader:** Set `tb_uart_loopback.v` as the top-level simulation module.
3.  **Run the Simulation:** Click `Run Simulation`.

## 4. Verify the Mission

The testbench will transmit data, which is encrypted, looped back, and decrypted. You will see messages in the Tcl Console confirming that the data received perfectly matches the data sent, proving the secure communication loop is working.

A successful mission looks like this:
```
Testbench: SUCCESS! Sent 0xa5 and received 0xa5.
Testbench: SUCCESS! Sent 0x3c and received 0x3c.
```
This confirms that even after being scrambled for transmission, your data arrived safely.
